#!/usr/bin/env bash
set -u
trap 'kill 0' EXIT

# Leave 30sec for the system to boot
sleep 30

SCRIPT_PATH=$(realpath $0)
DATA_DIR="/var/lib/motionui"
DB="$DATA_DIR/db/motionui.sqlite"
EVENTS_DIR="$DATA_DIR/events"
DAY=$(LC_ALL="en_EN.UTF-8" date +%A)
TIME=$(date +%H%M)
PING_RUNNING="no"
AUTOSTART_ENABLED=""
USE_DEVICE_PRESENCE=""
DEVICES_IP=""
ALERT_ENABLED=""
ALERT_RECIPIENT=""
MUTT_CMD=""
MUTT_CONF=""
COUNTER="0"

# Database and files checks
function generalChecks
{
    # Check that database exists
    if [ ! -f "$DB" ];then
        echo "Error: Database '$DB' not found."
        exit 1
    fi

    # Check that sqlite3 is present
    if [ ! -f "/usr/bin/sqlite3" ];then
        echo "Error: /usr/bin/sqlite3 not found."
        exit 1
    fi
}

# Check if this service needs to be restarted
function checkRestartNeeded
{
    if [ -f "$DATA_DIR/service.restart" ];then
        echo "A restart of this service is required. Restarting..."
        rm "$DATA_DIR/service.restart" -f
        exec systemctl --quiet restart motionui
    fi
}

# Get autostart configuration from database
function getAutostartConf
{
    # Get autostart configuration
    AUTOSTART_ENABLED=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT Status FROM autostart" | sed 's/ //g')

    # Get use_device_presence configuration
    USE_DEVICE_PRESENCE=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT Device_presence FROM autostart" | sed 's/ //g')
}

# Get alert configuration from database
function getAlertConf
{
    ALERT_ENABLED=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT Status FROM alerts" | sed 's/ //g')

    if [ "$ALERT_ENABLED" == "enabled" ];then
        ALERT_RECIPIENT=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT Recipient FROM alerts" | sed 's/ //g')

        # If no mail recipient is specified, disable alert
        if [ -z "$ALERT_RECIPIENT" ];then
            echo "Error: No mail recipient configured, alert(s) will not be send."
            
            ALERT_ENABLED="disabled"
            
            return
        fi

        # Get mutt config file path if specified
        MUTT_CONF=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT Mutt_config FROM alerts" | sed 's/ //g')

        # Get alert time slot for the actual day
        getAlertTime
    fi
}

# Get known devices IP
function getDevicesIp
{
    DEVICES_IP=$(/usr/bin/sqlite3 -noheader -batch -column -cmd '.timeout 5000' "$DB" "SELECT Ip FROM devices")
}

function startMotion
{
    if ! systemctl is-active --quiet motion;then
        systemctl start motion

        # If motion has started successfully, add a new status in database
        if [ "$?" -eq "0" ];then
            MOTION_STATUS="active"
            setDbMotionStatus
        fi
    fi
}

function stopMotion
{
    if systemctl is-active --quiet motion;then
        systemctl stop motion

        # If motion has stopped successfully, add a new status in database
        if [ "$?" -eq "0" ];then
            MOTION_STATUS="inactive"
            setDbMotionStatus
        fi
    fi
}

# Check if a start or stop of motion is needed
function startStopMotion
{
    # Start motion if following file is present
    if [ -f "$DATA_DIR/start-motion.request" ];then
        startMotion
        rm -f "$DATA_DIR/start-motion.request"
    fi

    # Stop motion if following file is present
    if [ -f "$DATA_DIR/stop-motion.request" ];then
        stopMotion
        rm -f "$DATA_DIR/stop-motion.request"
    fi
}

# Get autostart time slot for actual day
function getAutostartTime
{
    AUTOSTART_TODAY_START=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT ${DAY}_start FROM autostart" | sed 's/ //g' | sed 's/://g')
    AUTOSTART_TODAY_END=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT ${DAY}_end FROM autostart" | sed 's/ //g' | sed 's/://g')

    # If end time has been set at 00:00, then motion should run until the end of the day.
    # So convert it to a high number to pass all conditions and be sure that motion will run till the end of the day.
    if [ "$AUTOSTART_TODAY_END" == "0000" ];then
        AUTOSTART_TODAY_END="9999"
    fi
}

# Get alert time slot for actual day
function getAlertTime
{
    ALERT_TODAY_START=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT ${DAY}_start FROM alerts" | sed 's/ //g' | sed 's/://g')
    ALERT_TODAY_END=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT ${DAY}_end FROM alerts" | sed 's/ //g' | sed 's/://g')

    # If end time has been set at 00:00, then alert should always be send until the end of the day.
    # So convert it to a high number to pass all conditions and be sure to send alert till the end of the day.
    if [ "$ALERT_TODAY_END" == "0000" ];then
        ALERT_TODAY_END="9999"
    fi
}

# Set motion status in database
function setDbMotionStatus
{
    CURRENT_DATE=$(date +%Y-%m-%d)
    CURRENT_TIME=$(date +%H:%M:%S)
    /usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "INSERT INTO motion_status (Date, Time, Status) VALUES ('$CURRENT_DATE', '$CURRENT_TIME', '$MOTION_STATUS')"
}

# Check if a new version is available on Github
function checkVersion
{
    if [ -f "${DATA_DIR}/version.available" ];then
        curl -s -H 'Cache-Control: no-cache' "https://raw.githubusercontent.com/lbr38/motion-UI/main/www/version" > ${DATA_DIR}/version.available
    fi
}

# Send a mail alert on a new motion event
function newEventAlert
{
    # Quit if one alert parameter is null
    if [ -z "$ALERT_TODAY_START" ] || [ -z "$ALERT_TODAY_END" ];then
        return
    fi

    # If actual time is between alert time slot, then send alert
    if [ "$TIME" -ge "$ALERT_TODAY_START" ] && [ "$TIME" -lt "$ALERT_TODAY_END" ];then

        # Building final mutt command
        MUTT_SUBJECT="[ Motion - event $EVENT_MOTION_ID ] - New motion detected"

        MUTT_MESSAGE="A new motion has been detected by this camera. Details:\n"
        MUTT_MESSAGE+="Date: $EVENT_DATE_START at $EVENT_TIME_START\n"
        MUTT_MESSAGE+="Camera id: $EVENT_CAMERA_ID\n"
        
        if [ ! -z "$MUTT_CONF" ];then
            echo -e "$MUTT_MESSAGE" | mutt -F "$MUTT_CONF" -s "$MUTT_SUBJECT" -- $ALERT_RECIPIENT &
        else
            echo -e "$MUTT_MESSAGE" | mutt -s "$MUTT_SUBJECT" -- $ALERT_RECIPIENT &
        fi
    fi
}

# Send a mail alert on a new motion event file
function newEventFileAlert
{
    # Quit if one alert parameter is null
    if [ -z "$ALERT_TODAY_START" ] || [ -z "$ALERT_TODAY_END" ];then
        return
    fi

    # If actual time is between alert time slot, then send alert
    if [ "$TIME" -ge "$ALERT_TODAY_START" ] && [ "$TIME" -lt "$ALERT_TODAY_END" ];then

        # Building final mutt command
        MUTT_SUBJECT="[ Motion - event $EVENT_MOTION_ID ] - Attached file from this event"

        MUTT_MESSAGE="A new file has been generated from the previous motion event. Details:\n"
        MUTT_MESSAGE+="Event Id: $EVENT_MOTION_ID\n"
        MUTT_MESSAGE+="Date: $EVENT_DATE_START at $EVENT_TIME_START\n"
        MUTT_MESSAGE+="Camera id: $EVENT_CAMERA_ID\n"

        if [ ! -z "$MUTT_CONF" ];then
            echo -e "$MUTT_MESSAGE" | mutt -F "$MUTT_CONF" -s "$MUTT_SUBJECT" -a "$EVENT_FILE" -- $ALERT_RECIPIENT &
        else 
            echo -e "$MUTT_MESSAGE" | mutt -s "$MUTT_SUBJECT" -a "$EVENT_FILE" -- $ALERT_RECIPIENT &
        fi
    fi
}

# Autostart and stop motion on configured time slots or device presence
function autostart
{
    # If device presence is enabled, check that at least one device is present 
    if [ "$USE_DEVICE_PRESENCE" == "enabled" ];then

        # Only run loop if not already running in background
        if [ "$PING_RUNNING" == "no" ];then

            # The ip scan will loop and work on its own to avoid hanging the whole service
            while true; do
                sleep 5

                # Always check if autostart and device presence are enabled, cause it can be disabled at any moment by the user from the web ui
                getAutostartConf

                if [ "$AUTOSTART_ENABLED" != "enabled" ] || [ "$USE_DEVICE_PRESENCE" != "enabled" ];then
                    continue
                fi

                # Get known devices
                getDevicesIp

                # Get all devices ip addresses
                if [ ! -z "$DEVICES_IP" ];then
                    for DEVICE_IP in $DEVICES_IP; do
                        # Try to ping the first device of the loop 
                        # If there is a response, then stop motion cause there is at least 1 device present on the network.
                        # Else, try to ping the next device

                        # There will be 2 pings tries for the same device. Some devices sometimes not respond on the first try but do on the second.
                        TRY_COUNT="0"

                        while [ "$TRY_COUNT" != "2" ];do
                            if ping -q -c1 -W2 -n "$DEVICE_IP" > /dev/null;then
                                if systemctl is-active --quiet motion;then
                                    echo "At least 1 active device has been found on the network - someone is home - stopping motion"
                                    stopMotion
                                fi

                                # Break this 'while' loop and go back to the 'while true' loop
                                continue 3
                            fi

                            (( TRY_COUNT++ ))
                        done
                    done

                    # If all the devices are absent from the local network, then start motion
                    # Start motion only if not already running
                    if ! systemctl is-active --quiet motion;then
                        echo "No active device found on the network - nobody is home - starting motion"
                        startMotion
                    fi
                fi
            done &

            PING_RUNNING="yes"
        fi

        return
    fi

    # If device presence is not enabled, start/stop motion on configured time slots

    # Get actual day and time
    DAY=$(LC_ALL="en_EN.UTF-8" date +%A)
    TIME=$(date +%H%M)

    # Get autostart time slots configuration for actual day
    getAutostartTime

    # If no autostart is configured for the actual day, then quit
    if [ -z "$AUTOSTART_TODAY_START" ] || [ -z "$AUTOSTART_TODAY_END" ];then
        return
    fi

    # If actual time is between autostart time slot, then start motion
    if [ "$TIME" -ge "$AUTOSTART_TODAY_START" ] && [ "$TIME" -lt "$AUTOSTART_TODAY_END" ];then
        # Start motion only if not already running
        if ! systemctl is-active --quiet motion;then
            echo "Starting motion according to autostart time configuration"
            startMotion
        fi

    # Else stop motion if running
    else
        if systemctl is-active --quiet motion;then
            echo "Stopping motion according to autostart time configuration"
            stopMotion
        fi
    fi
}

# Check if any new event files are present and register them if so.
function processEvent
{
    if [ ! -d "$EVENTS_DIR" ];then
        mkdir -p "$EVENTS_DIR"
    fi

    # If no new event are declared, quit
    if [ ! "$(ls -A $EVENTS_DIR/)" ];then
        return
    fi

    # Else process each event file
    for EVENT in $(ls -A1 $EVENTS_DIR/);do
        EVENT_MOTION_ID=$(grep "^ID=" $EVENTS_DIR/$EVENT | sed 's/ID=//g')
        EVENT_STATUS=$(grep "^STATUS=" $EVENTS_DIR/$EVENT | sed 's/STATUS=//g')
        EVENT_DATE_START=$(grep "^DATE_START=" $EVENTS_DIR/$EVENT | sed 's/DATE_START=//g')
        EVENT_TIME_START=$(grep "^TIME_START=" $EVENTS_DIR/$EVENT | sed 's/TIME_START=//g')
        EVENT_CAMERA_ID=$(grep "^CAMERA_ID=" $EVENTS_DIR/$EVENT | sed 's/CAMERA_ID=//g')
        EVENT_CAMERA_NAME=$(grep "^CAMERA_NAME=" $EVENTS_DIR/$EVENT | sed 's/CAMERA_NAME=//g')
        EVENT_FILES=$(grep "^FILE=" $EVENTS_DIR/$EVENT | sed 's|FILE=||g')

        # If the event have never been processed before, then add it to database
        if [ "$EVENT_STATUS" == "new" ] && [ ! -z "$EVENT_DATE_START" ] && [ ! -z "$EVENT_TIME_START" ];then        
            # Add event to database
            /usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "INSERT INTO motion_events (Motion_id_event, Date_start, Time_start, Camera_id, Camera_name, Status) VALUES ('$EVENT_MOTION_ID', '$EVENT_DATE_START', '$EVENT_TIME_START', '$EVENT_CAMERA_ID', '$EVENT_CAMERA_NAME', 'processing')"

            # Then change its status to processing and leave it until DATE_END and TIME_END are added to the file
            sed -i 's/STATUS=.*/STATUS=processing/g' "$EVENTS_DIR/$EVENT"

            # Send alert if enabled
            if [ "$ALERT_ENABLED" == "enabled" ];then
                newEventAlert
            fi
        fi

        # Get event autoincrement Id in database, it will be needed for next operations
        EVENT_ID=$(/usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "SELECT Id FROM motion_events WHERE Motion_id_event='$EVENT_MOTION_ID' AND Date_start='$EVENT_DATE_START' AND Time_start='$EVENT_TIME_START'")

        # Process file and close event only if it has already an Id in database
        if [ ! -z "$EVENT_ID" ];then
            # If the event has files then add their location to database
            if [ ! -z "$EVENT_FILES" ];then
                for EVENT_FILE in $EVENT_FILES;do
                    # If the file has not already been added to database then add it
                    if ! echo "$EVENT_FILE" | grep -q ":processed";then

                        /usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "INSERT INTO motion_events_files (File, Id_event) VALUES ('$EVENT_FILE', '$EVENT_ID')"

                        # Send alert with the file attached, if enabled
                        if [ "$ALERT_ENABLED" == "enabled" ];then
                            newEventFileAlert
                        fi

                        # Change file status to 'processed' in the file to prevent it from been processed multiple times
                        sed -i "s|$EVENT_FILE|${EVENT_FILE}:processed|g" "$EVENTS_DIR/$EVENT"
                    fi
                done
            fi

            # If the event has a DATE_END and a TIME_END, then close the event
            if [ "$EVENT_STATUS" == "processing" ];then
                EVENT_DATE_END=$(grep "DATE_END=" $EVENTS_DIR/$EVENT | sed 's/DATE_END=//g')
                EVENT_TIME_END=$(grep "TIME_END=" $EVENTS_DIR/$EVENT | sed 's/TIME_END=//g')

                if [ ! -z "$EVENT_DATE_END" ] && [ ! -z "$EVENT_TIME_END" ];then
                    # Close the event in database
                    /usr/bin/sqlite3 -noheader -batch -cmd '.timeout 5000' "$DB" "UPDATE motion_events SET Date_end = '$EVENT_DATE_END', Time_end = '$EVENT_TIME_END', Status = 'done' WHERE Id = '$EVENT_ID'"

                    # Then delete the event file
                    rm -f "$EVENTS_DIR/$EVENT"
                fi
            fi
        fi
    done
}

# Check if this service needs to be restarted
function checkRestartNeeded
{
    if [ -f "$DATA_DIR/service.restart" ];then
        echo "A restart of this service is required. Restarting..."
        rm "$DATA_DIR/service.restart" -f
        exec systemctl --quiet restart motionui
    fi
}

# Execution
while true; do
    # Check if a restart of this service is needed
    checkRestartNeeded
    
    # Execute actions on service start (COUNTER = 0) and then every hour (COUNTER = 720)
    # 3600 / 5sec (sleep 5) = 720
    if [ "$COUNTER" -eq "0" ] || [ "$COUNTER" -eq "720" ];then
        # Check version
        checkVersion

        # Reset counter
        COUNTER="0"
    fi

    # Check if a restart of this service is needed
    checkRestartNeeded

    # Check that conf files exists
    generalChecks

    # Start/stop motion if asked
    startStopMotion

    # Get conf from conf files
    getAutostartConf
    getAlertConf

    # Process event if there are, and send alert if needed
    processEvent

    if [ "$AUTOSTART_ENABLED" == "enabled" ];then
        autostart
    fi

    sleep 5

    (( COUNTER++ ))
done

exit